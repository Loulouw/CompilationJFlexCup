/*
 * analyseur syntaxique  du langage exemple-expr:
 * expression arithmetique
 * (voir supports de cours)
 *
 * auteur : azim.roussanaly@univ-lorraine.fr
 * (c) 2013
 */ 
package fr.ul.miage.exemple.generated;

import java.util.*;
import fr.ul.miage.exemple.symbol.*;
import fr.ul.miage.exemple.arbre.*;
import java.util.regex.*;

/* Fonctions */
action code 
{:
	private Programme programme = new Programme();

	private ArrayList<Symbol> symbols = new ArrayList<>();
	private ArrayList<SymbolVar> symbolParams = new ArrayList<>();
	private ArrayList<SymbolVar> symbolVarsLoc = new ArrayList<>(); 
	private ArrayList<Noeud> noeudsFonction = new ArrayList<>();
	
	private int rangVarGlobal = 0;

	private Pattern patternVariable = Pattern.compile("^[a-zA-Z]+$");
	private Pattern patternConstante = Pattern.compile("^-?[0-9]+$");

 	public void ajouterVar(String str,boolean glob){
		String values[] = str.split(",");
		
		for(String value : values){
			String s[] = value.split(" ");
			try{
				if(glob){
					int val = 0;
					if(s.length == 2) val = Integer.parseInt(s[1].trim());
					SymbolVarGlob sym = new SymbolVarGlob(s[0].trim(), "int", "glob", val, rangVarGlobal);
					symbols.add(sym);
					rangVarGlobal ++;
				}else{	
					SymbolVar sym = new SymbolVar(s[0].trim(),"int","loc",symbolVarsLoc.size());
					symbolVarsLoc.add(sym);
				}
			}catch(Exception e){
				e.printStackTrace();
			}
		}
	}



	public void ajouterFunc(String str){
		String values[] = str.split(" ");
		SymbolFunc sym = new SymbolFunc(values[1].trim(),values[0].trim(),"func",symbolVarsLoc.size(),symbolParams.size());
		symbols.add(sym);

		Fonction fonction = new Fonction(symbols.size() - 1);
		programme.ajouterFonction(fonction);

		for(Symbol s : symbolParams) symbols.add(s);
		for(Symbol s : symbolVarsLoc) symbols.add(s);
		symbolParams.clear();
		symbolVarsLoc.clear();
	}



	public void ajouterParam(String str){
		String values[] = str.split(" ");
		SymbolVar sym = new SymbolVar(values[1].trim(),"int","param",symbolParams.size());
		symbolParams.add(sym);
	}



	public void ajouterAffectation(String str){
		String values[] = str.split(" ");
		Variable variable = new Variable(getVariablePlace(values[0].trim());
		String expression = values[1].trim();			
		Noeud objet;

		if(patternConstante.matcher(expression).find()){
			int cons = Integer.parseInt(values[1].trim());
			objet = new Constante(cons);
		}else if(patternVariable.matcher(expression).find(){
			objet = new Variable(getVariablePlace(expression));
		}else{
			//Calcul a gerer
		}

		Affectation affectation = new Affectation(variable,objet);
		noeudsFonction.add(affectation);
	}





	private int getVariablePlace(String name){
		int res = -1;
		ArrayList<Symbol> array = new ArrayList<>();
		array.addAll(symbols);
		array.add(new SymbolFunc("","","func",0,0));
		array.addAll(symbolParams);
		array.addAll(symbolVarsLoc);

		for(int i=array.size()-1;i>=0;i--){
			Symbol s = symbols.get(i);
			if(s.getNom().equals(name) && !s.getCat().equals("func")){
				res = i;
				break;
			}	
		}
		return res;
	}


	public void fin(){
		for(Symbol s : symbols) System.out.println(s);
	}
:}

/* la grammaire */
terminal CRO_OUVR, CRO_FERM, RETOUR, ESPACE, PV, VIRG;
terminal COMMENTAIRE;
terminal FUNC, NOM, NOMBRE, RETURN;
terminal INT, NOTHING;
terminal PLUS,MOINS,FOIS,DIV,PO,PF,EGAL,INF,SUP,DIFF;
terminal SI,SINON,TQ;
terminal LIRE,ECRIRE;


non terminal l, ligne, fonction, actions, content_function, content_function_list;
non terminal type, declaration_var,declaration_var_mul_nom, declaration_var_mul, declaration_var_mul_value, declaration_value;
non terminal affectation, calcul;
non terminal return, appel_fonction, param_appel_fonction, param_appel_fonction_rec;
non terminal param_fonction, param_fonction_rec;
non terminal c2,c3,c4,c5;
non terminal si,sinon,tq, condition, s2,s3,s4,s5;
non terminal ecrire;

//Precedences added by Eclipse plugin
precedence nonassoc PO;	// Inserted by Eclipse plugin

start with l;

l				::= actions {: fin(); :};

actions			::= actions ligne | /*vide*/;

ligne			::= fonction 
				| COMMENTAIRE 
				| declaration_var:a {: ajouterVar(a.toString(),true); :}
				| declaration_var_mul:a {: ajouterVar(a.toString(),true); :} 
				| RETOUR 
				| ESPACE ;

type			::= INT:a {: RESULT=a.toString(); :} 
				| NOTHING:a {: RESULT=a.toString(); :};

/***********************************************/
/***************FONCTION************************/
/***********************************************/

fonction		::= FUNC ESPACE type:a ESPACE NOM:b param_fonction_rec CRO_OUVR content_function CRO_FERM {: ajouterFunc(a.toString() + " " + b.toString()); :};

param_fonction_rec ::= param_fonction_rec param_fonction | /*vide*/ ;

param_fonction ::= ESPACE type:a ESPACE NOM:b VIRG {: ajouterParam(a.toString() + " " + b.toString()); :} 
				| ESPACE type:a ESPACE NOM:b {: ajouterParam(a.toString() + " " + b.toString()); :};


content_function	::= content_function content_function_list | /*vide*/ ;

content_function_list ::= RETOUR | COMMENTAIRE 
						| si 
						| tq 
						| ecrire 
						| return 
						| appel_fonction PV 
						| affectation:a {::}
						| declaration_var:a {: ajouterVar(a.toString(),false); :}  
						| declaration_var_mul:a {: ajouterVar(a.toString(),false); :};

return 			::= RETURN ESPACE calcul PV ;

/***********************************************/
/***************FIN FONCTION********************/
/***********************************************/






/***********************************************/
/***************CONDITION/BOUCLE****************/
/***********************************************/
si ::= SI PO condition PF CRO_OUVR content_function CRO_FERM sinon;

sinon ::= SINON CRO_OUVR content_function CRO_FERM | /* vide */;

tq ::= TQ PO condition PF CRO_OUVR content_function CRO_FERM;

condition ::= condition INF s2 | s2;

s2 ::= s2 SUP s3 | s3;

s3 ::= s3 DIFF s4 | s4;

s4 ::= s4 EGAL s5 | s5;

s5 ::= calcul;

/***********************************************/
/***************FIN CONDITION/BOUCLE************/
/***********************************************/







/***********************************************/
/***************CALCUL**************************/
/***********************************************/
calcul ::= calcul:a PLUS c2:b {: RESULT=a.toString() + "+" + b.toString(); :}
		| c2:a {: RESULT=a.toString(); :};

c2 ::= c2:a MOINS c3:b {: RESULT=a.toString() + "-" + b.toString(); :}
		| c3:a {: RESULT=a.toString(); :};

c3 ::= c3:a FOIS c4:b {: RESULT=a.toString() + "*" + b.toString(); :}
		| c4:a {: RESULT=a.toString(); :};

c4 ::= c4:a DIV c5:b {: RESULT=a.toString() + "/" + b.toString(); :}
		| c5:a {: RESULT=a.toString(); :};

c5 ::= appel_fonction :a {: RESULT=a.toString(); :}
	| NOMBRE:a {: RESULT=a.toString(); :}
	| PO calcul PF :a {: RESULT=a.toString(); :}
	| NOM:a {: RESULT=a.toString(); :};


/***********************************************/
/***********FIN CALCUL**************************/
/***********************************************/






/***********************************************/
/***************VARIABLE************************/
/***********************************************/
affectation		::= NOM:a EGAL declaration_value:b PV {: RESULT=a.toString() + " " + b.toString();:};

declaration_var	::= type ESPACE NOM:n EGAL declaration_value:v PV {: RESULT=n.toString() + " " + v.toString(); :};

declaration_var_mul ::= type ESPACE NOM:n declaration_var_mul_nom:v PV {: RESULT=n.toString() + " " + v.toString(); :};

declaration_var_mul_nom ::= declaration_var_mul_nom VIRG NOM:a declaration_var_mul_value:b {: RESULT="," + a.toString() + " " + b.toString(); :}
						  | /*vide*/ {:RESULT="";:};

declaration_var_mul_value ::= EGAL declaration_value:a {: RESULT=a.toString(); :}
							| /* vide */ {: RESULT=""; :};

declaration_value ::= LIRE PO PF 
					| calcul:c {: RESULT = c.toString(); :};

ecrire ::= ECRIRE PO calcul PF PV;

/***********************************************/
/***************FIN VARIABLE********************/
/***********************************************/








/***********************************************/
/***************APPEL FONCTION******************/
/***********************************************/

appel_fonction		::= NOM:n PO param_appel_fonction_rec:p PF  {: RESULT=n.toString() + " " + p.toString(); :};

param_appel_fonction_rec ::= param_appel_fonction_rec param_appel_fonction:p {: RESULT = p.toString(); :}
						| /*vide*/;

param_appel_fonction ::= calcul:c {: RESULT=c.toString(); :}
						| VIRG calcul:c {: RESULT=c.toString(); :};

/***********************************************/
/***************FIN APPEL FONCTION**************/
/***********************************************/